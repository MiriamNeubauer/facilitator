================================================
== Me doing our codereltics tutorial on a Mac ==
================================================

1. mkdir xxx
2. rails new xxx
3. open in subl .
4. test 'rails s' on localhost:3000
5. rails g controller sites
6. a) def index end into sites-controller
   b) create index.html.erb
   c) root 'sites#index'
7. a) RVM --> install rvm locally (1 file), check: rvm gemset list_all
   b) POW and Anvil --> pow lets you use native domains like xxxx.dev. simulates real-life domain behavior like running multiple apps in parallel and displaying subdomains such as blog.xxxx.dev. Anvil = pow for lazy people. get it running by setting up symlinks. This is how to create symlinks:
   	$ cd ~/.pow
	$ ln -s ~/Projects/myapp (or whatever your app-path is after ~ in CL)
8. Git:
   Create Account.
   brew install git
   Connect local machine to online account: 
   		git config --global user.name "YOUR-USERNAME"
		git config --global user.email YOUR-EMAIL-ADDRESS
		git config --global credential.helper cache
   Set up github repo for app: while cd'd in xxx-folder:
   		touch README.md
		git init
		git add README.md
		git commit -m "first commit"
		git remote add origin git@github.com:MiriamNeubauer/pinmazing.git
		git push -u origin master // git pull
	Work in seperate branch to start:
		git checkout -b pages
9. Weiter gehts:
	rails generate controller Pages home imprint (home and imprint are views)
	(just example: rails destroy controller Pages home imprint)
	In routes: Pinmazing::Application.routes.draw do
  		get "pages/home"
  		get "pages/imprint"
	  end
	Customize file: Pages > home.html.erb
	Adjust routes root to pages#home
	Add contact-page in routes and views plus action in the controller
10. Playing around:
	<%= Time.now.strftime ("%m/%d/%Y") %>
	<%= link_to "Home", root_path %>
	<%= link_to "Imprint", imprint_path %>
11. Every route has a path method that can be called by extending the 		prefix with "_path", e.g. "pages_contact_path" will redirect to 		"pages#contact".
12. Make code pretty / DRY by using partials for the header and footer (instead of just putting it the duplicate code out	of individual files and into application.html.erb, by naming the files with underscores)
13. Bootstrap getbootstrap.com / foundation / ionicframework for mobile: CSS, JS for dynamics and customize-option for colors/spacing etc. . Searcj "navbar" => alls SCSS are customizable
	a) clean up gemfile by structuring comments to the right
	b) Ruby: install Bootstrap via gem instead of downloading, via https://github.com/twbs/bootstrap-sass (saas is an extension of css, css with superpowers)
	c) bundle
	d) create custom.css.scss to include the installed bootstrap there via @import "bootstrap-sprockets";
	d) require bootstrap sprockets in application.js
14. Wrap yield into div with class container
15. Navigation:
	a) copy first navbar from boostrap. info: navbar-header is needed for responsiveness-reasons
	b) customize it: 
		- replace <a> to brand link to <%= link_to %> while keeping the same class
		- put contact, imprint into footer
		- footer: copy navbar but take out mobile-responsive part
		- attention in footer (and nav in general): format needs to match bootstrap-standard, e.g. <ul> in navbar needs to be followed by <li> <a> bzw. <%= link_to otherwise it won't be displayed correctly. e.g. if I leave out the link-to part in the footer before "made with love", it will be scrooched to the upper side instead of centered.
16. Make body prettier:
	a) wrap content in home.html.erb into class=panel
	b) add bootstrap buttons
	c) customize bootstrap default scss variables. Achtung: diese muessen in customize.css.scss unbedingt vor dem Import der Bootstrap sprockets sein! Achtung 2: LESS is with @ (bootstrap) and we write in SASS with $ => customized bootstrap variables in our files need to be written with a $
	d) fonts: @import from google fonts, and then call on it via $-sign and less-variable as defined by bootstrap in the customize-section. 
	e) Achtung: manchmal werden bei den Bootstrap-Variablen mehrere ineinander verschachtelt, z.B. bei brand-primary (statt einer Farbe wird das spezifiziert)
	f) Als wir //centralize brand gemacht haben in custom.scss, da ging dann zuerst bei mobile responsive der Toggle-Button nicht mehr. Aber dann als wir toggle auf z-index = 1 gesetzt haben, ging es wieder.
	g) adding custom class "red" and class "center"
	h) fix navbar to top => what happens first: navbar overlaps content (that is normal). to fix it we just have to add padding to top of body in the height of the navbar.
	i) use center-class to center panel in home.html.erb
	j) add something to scale viewport to retina: http://www.quirksmode.org/mobile/metaviewport/
17. Heroku-launch:
	a) if not done yet: install Heroku toolbelt
	b) 'heroku login' in the console
	c) 'heroku keys:add' (do only once for your system)
	d) create heroku app 'heroku create pinmazing-mcn'
	e) move sqlite-gem to development, and group the gems
	f) bundle install BUT without the production gems because installing PG on machine can be hassle (plus we do not need it) --> 'bundle install --without production'
	g) rake assets:precompile RAILS_ENV=production
	h) push to heroku
18. Domain Hosters: he uses Dnsimple.com
	a) added own domain in heroku and on united domains dns forwarding
19. Using Devise for authentication: https://github.com/plataformatec/devise
	a) add gem'devise' to gemfile. bundle install
	b) as told 
	c) as told in CL:
		1)  add to development.rb at bottom before end: 
		    # required for devise
  			config.action_mailer.default_url_options = { host: 'localhost', port: 3000 }
  		2) add to production.rb before end:
  			# required for heroku and devise. I used pinmazing, as this is my domain. Set it to your Domain as soon as you know it. For example, you could use your heroku address: xyz.herokuapp.com
  			config.action_mailer.default_url_options = { :host => 'pinmazing.com' }
  		3) set flash messages in application.html.eb by adding this before yield and into the container:
  			<% flash.each do |name, msg| %>
			<%= content_tag(:div, msg, class: "alert alert-info") %>
			<% end %>
		4) precompiling assets not needed in Rails 4 anymore so we skip that
		5) rails g devise:views to get the templates
			=> passwords/new means reset password
			=> sessions/new means Login
			=> registrations/new means Signup
		6) Adding models and database
			a) rails generate devise user (rails destroy devise user), rake db:migrate [rake is a task manager. always restart server after migration.]
			b) look at schema.rb
20. Set up Signup and Login views
	a) devise added routes for that automatically. rake routes
	b) We will use 2 of the routes for sign up and log in. Guess which?

	new_user_session_path
	new_user_registration_path

	To create an area only for users that are signed in, we use some of the devise helpers and controller filters:

	user_signed_in?

	Add that around content of home.html.erb:
		<% if !user_signed_in? %>
		<% end %>
	c) add routes to _header.html.erb, as well as if-clause for what the user sees depending on whether he is signed in or not
21. Adding name to User-model
	a) rails g migration AddNameToUsers name:string
	   rake db:migrate
	b) in application_controller.rb (line 6-10): We have to tell devise that "name" is permitted for signing up and also editing your account. If you don't do that, the typed in name will not be saved.
22. User.rb - make user management views prettier:
	a) Sign up @app/views/devise/registrations/new.html.erb: 
		1) wrap everything in a panel
		2) put panel-heading class around heading, and body into div with class panel-body, as well as panel-footer
		3) put each field into class "form-group" which makes it that nice box with rounded corners. and add class "form-control" to add nice spacing to that new box.
	b) do the same for @app/views/devise/registrations/edit.html.erb
	c) edit @app/views/devise/sessions/new.html.erb in same way
	d) edit @app/views/devise/passwords/new.html.erb in same way
	e) edit @app/views/devise/passwords/edit.html.erb in same way
	f) rake assets:precompile RAILS_ENV=production, git push heroku master, heroku run rake db:migrate
23. Build the Logic around Users and Pins:
	Looking at Facebook, you find a lot of "resources": Images in general are a resource. They can be created, shown, edited, and deleted. Same is true in general for messages, users, your feed, videos, and so on. Looking at Twitter, tweets and users would also be resources each.
	For Pinterest and our web page, we have users and pins. Later, we will also have comments as a resource. Basically, whatever "thing/feature" you have in mind that should be possible to be created, read, updated, and destroyed you talk about a resource.

	In tech talk, that is also called CRUD. 'C'reate, 'R'ead, 'U'pdate, and 'D'estroy.

	To generate a resource, Rails has a pretty cool concept called "scaffolding" which helps us to generate resource with a single command.
	To creat a resource, we need a model, views and a controller including the CRUD methods like create a pin, read/show a pin, update a pin and delete a pin.
	"A scaffold in Rails is a full set of model, database migration for that model, controller to manipulate it, views to view and manipulate the data, and a test suite for each of the above."

	a) Resources in DB: USERS, PINS, and later: COMMENTS <-- CRUD on them. 
	--> rails g -h (see all commands possible with generatie-action)
	=> rails g scaffold Pin description:string
	--> error told me to do: rake db:migrate RAILS_ENV=development
	--> a look at http://pinmazing-mcn.dev/pins (local pins-site) shows different layout b/c of the stylesheets that were auto-added by the scaffold, c.f. scaffolds.css.scss
	--> too many files were auto-generated during the scaffold
	--> need to remove some
	--> but first go again to http://pinmazing-mcn.dev/pins and create some pins and plaz around with it 
	=> look at how URL changes -> do you get the pattern yet?. do rake routes to see.
	e.g.: "CL:To give an example, localhost:3000/pins/1/edit will call the edit action on the controller which renders the edit.html.erb in the views/pins. Based on your input there, the controller interprets your data and passes your input via the model to the database."
	b) "CL: Build out the logic for the Pins controller

	Scaffolding is very helpful when you are starting with Rails. Later you will build your resources yourself. Why?

	Scaffolds create a lot of code in the controller that we do not need and which looks pretty crazy right now. Let's delete code that we will not need to focus on understanding the important parts of the Pins-controller:

	- delete JSON files 
	- What is that and why dont we need it?
	- simplify the controller and also delete the JSON code"
	=> deleted app/views/pins/index.json.jbuilder
	=> deleted app/views/pins/show.json.jbuilder, we do not need those files. They are only confusing at the moment.
	c) added some if-else statements in the pins_controller.rb
	d) Responders
		--> explanation of Responders in rails: http://asciicasts.com/episodes/224-controllers-in-rails-3
		--> "How does the respond_with method work? For a simple GET request like index it looks for a view file to render for the appropriate MIME type, such as an .html.erb file and will render it. If respond_with fails to find a view file then it will try to call a method like to_xml or to_json to render the object that was passed in the appropriate format."
	e) Edit _form.html.erb to include bootstrap-styling
24. CONNECT USERS TO THEIR RESPECTIVE PINS (Currently: anyone can access and create pins. Let's change that to only registered people to be able to create pins.)
	a) First of all, we have to connect users and pins, because pins can be created and deleted by anyone. Right now, your app does not know a pin belongs to a user. It is rather like: "oh, there are users and also there are pins", unaware of any connection.
	We have to teach our app next that there is a connection, but wait...What type of a connection is it?

	Resources can have 6 different types of relationships, let's go through them one by one.

	belongs_to, has_one, .... show all 6 types on rails basics page

	To define associations, you have to keep always 2 steps in mind:

	1. define the type of associations in your models

	2. tell your database that there is a connection by doing a migration
	=> in MODEL user.rb and pin.rb, create the relation
	=> rails generate migration AddUserIdToPins user_id:integer:index
	=> rake db:migrate

	b) check Commands in the Rails console:
		> pin = Pin.first
		> pin # will show you the first pin, as you just put it in that variable
		> pin.user_id = 1
		> pin.save
		> user = User.first 
		> user.pins
	The cool thing is that we have the following associations now set up:
		user.pins
		pin.user
	c) Adjust the frontend views to reflect the backend associations

	So far, we only did the connection between users and pins in the console. This is not reflected in the app yet. We do this by updating our controller and views.

	Devise helps us here with a method called "current_user". "Current_user" gives us the user that initiated the controller action.
	=> in pins_controller.rb: 
		=> in def new end: instead of @pin = Pin.new, it needs to be @pin = current_user.pins.build
		=> same in def create end
		--> pin.user and user.pins works NOW!
		=> add new method def correct_user end into private-methods-section




























	

















