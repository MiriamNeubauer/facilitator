================================================
== Me doing our codereltics tutorial on a Mac ==
================================================

[[ ERRORS: 25., ]]

1. mkdir xxx
2. rails new xxx
3. open in subl .
4. test 'rails s' on localhost:3000
5. rails g controller sites
6. a) def index end into sites-controller
   b) create index.html.erb
   c) root 'sites#index'
7. a) RVM --> install rvm locally (1 file), check: rvm gemset list_all
   b) POW and Anvil --> pow lets you use native domains like xxxx.dev. simulates real-life domain behavior like running multiple apps in parallel and displaying subdomains such as blog.xxxx.dev. Anvil = pow for lazy people. get it running by setting up symlinks. This is how to create symlinks:
   	$ cd ~/.pow
	$ ln -s ~/Projects/myapp (or whatever your app-path is after ~ in CL)
8. Git:
   Create Account.
   brew install git
   Connect local machine to online account: 
   		git config --global user.name "YOUR-USERNAME"
		git config --global user.email YOUR-EMAIL-ADDRESS
		git config --global credential.helper cache
   Set up github repo for app: while cd'd in xxx-folder:
   		touch README.md
		git init
		git add README.md
		git commit -m "first commit"
		git remote add origin git@github.com:MiriamNeubauer/pinmazing.git
		git push -u origin master // git pull
	Work in seperate branch to start:
		git checkout -b pages
9. Weiter gehts:
	rails generate controller Pages home imprint (home and imprint are views)
	(just example: rails destroy controller Pages home imprint)
	In routes: Pinmazing::Application.routes.draw do
  		get "pages/home"
  		get "pages/imprint"
	  end
	Customize file: Pages > home.html.erb
	Adjust routes root to pages#home
	Add contact-page in routes and views plus action in the controller
10. Playing around:
	<%= Time.now.strftime ("%m/%d/%Y") %>
	<%= link_to "Home", root_path %>
	<%= link_to "Imprint", imprint_path %>
11. Every route has a path method that can be called by extending the 		prefix with "_path", e.g. "pages_contact_path" will redirect to 		"pages#contact".
12. Make code pretty / DRY by using partials for the header and footer (instead of just putting it the duplicate code out	of individual files and into application.html.erb, by naming the files with underscores)
13. Bootstrap getbootstrap.com / foundation / ionicframework for mobile: CSS, JS for dynamics and customize-option for colors/spacing etc. . Searcj "navbar" => alls SCSS are customizable
	a) clean up gemfile by structuring comments to the right
	b) Ruby: install Bootstrap via gem instead of downloading, via https://github.com/twbs/bootstrap-sass (saas is an extension of css, css with superpowers)
	c) bundle
	d) create custom.css.scss to include the installed bootstrap there via @import "bootstrap-sprockets";
	d) require bootstrap sprockets in application.js
14. Wrap yield into div with class container
15. Navigation:
	a) copy first navbar from boostrap. info: navbar-header is needed for responsiveness-reasons
	b) customize it: 
		- replace <a> to brand link to <%= link_to %> while keeping the same class
		- put contact, imprint into footer
		- footer: copy navbar but take out mobile-responsive part
		- attention in footer (and nav in general): format needs to match bootstrap-standard, e.g. <ul> in navbar needs to be followed by <li> <a> bzw. <%= link_to otherwise it won't be displayed correctly. e.g. if I leave out the link-to part in the footer before "made with love", it will be scrooched to the upper side instead of centered.
16. Make body prettier:
	a) wrap content in home.html.erb into class=panel
	b) add bootstrap buttons
	c) customize bootstrap default scss variables. Achtung: diese muessen in customize.css.scss unbedingt vor dem Import der Bootstrap sprockets sein! Achtung 2: LESS is with @ (bootstrap) and we write in SASS with $ => customized bootstrap variables in our files need to be written with a $
	d) fonts: @import from google fonts, and then call on it via $-sign and less-variable as defined by bootstrap in the customize-section. 
	e) Achtung: manchmal werden bei den Bootstrap-Variablen mehrere ineinander verschachtelt, z.B. bei brand-primary (statt einer Farbe wird das spezifiziert)
	f) Als wir //centralize brand gemacht haben in custom.scss, da ging dann zuerst bei mobile responsive der Toggle-Button nicht mehr. Aber dann als wir toggle auf z-index = 1 gesetzt haben, ging es wieder.
	g) adding custom class "red" and class "center"
	h) fix navbar to top => what happens first: navbar overlaps content (that is normal). to fix it we just have to add padding to top of body in the height of the navbar.
	i) use center-class to center panel in home.html.erb
	j) add something to scale viewport to retina: http://www.quirksmode.org/mobile/metaviewport/
17. Heroku-launch:
	a) if not done yet: install Heroku toolbelt
	b) 'heroku login' in the console
	c) 'heroku keys:add' (do only once for your system)
	d) create heroku app 'heroku create pinmazing-mcn'
	e) move sqlite-gem to development, and group the gems
	f) bundle install BUT without the production gems because installing PG on machine can be hassle (plus we do not need it) --> 'bundle install --without production'
	g) rake assets:precompile RAILS_ENV=production
	h) push to heroku
18. Domain Hosters: he uses Dnsimple.com
	a) added own domain in heroku and on united domains dns forwarding
19. Using Devise for authentication: https://github.com/plataformatec/devise
	a) add gem'devise' to gemfile. bundle install
	b) as told 
	c) as told in CL:
		1)  add to development.rb at bottom before end: 
		    # required for devise
  			config.action_mailer.default_url_options = { host: 'localhost', port: 3000 }
  		2) add to production.rb before end:
  			# required for heroku and devise. I used pinmazing, as this is my domain. Set it to your Domain as soon as you know it. For example, you could use your heroku address: xyz.herokuapp.com
  			config.action_mailer.default_url_options = { :host => 'pinmazing.com' }
  		3) set flash messages in application.html.eb by adding this before yield and into the container:
  			<% flash.each do |name, msg| %>
			<%= content_tag(:div, msg, class: "alert alert-info") %>
			<% end %>
		4) precompiling assets not needed in Rails 4 anymore so we skip that
		5) rails g devise:views to get the templates
			=> passwords/new means reset password
			=> sessions/new means Login
			=> registrations/new means Signup
		6) Adding models and database
			a) rails generate devise user (rails destroy devise user), rake db:migrate [rake is a task manager. always restart server after migration.]
			b) look at schema.rb
20. Set up Signup and Login views
	a) devise added routes for that automatically. rake routes
	b) We will use 2 of the routes for sign up and log in. Guess which?

	new_user_session_path
	new_user_registration_path

	To create an area only for users that are signed in, we use some of the devise helpers and controller filters:

	user_signed_in?

	Add that around content of home.html.erb:
		<% if !user_signed_in? %>
		<% end %>
	c) add routes to _header.html.erb, as well as if-clause for what the user sees depending on whether he is signed in or not
21. Adding name to User-model
	a) rails g migration AddNameToUsers name:string
	   rake db:migrate
	b) in application_controller.rb (line 6-10): We have to tell devise that "name" is permitted for signing up and also editing your account. If you don't do that, the typed in name will not be saved.
22. User.rb - make user management views prettier:
	a) Sign up @app/views/devise/registrations/new.html.erb: 
		1) wrap everything in a panel
		2) put panel-heading class around heading, and body into div with class panel-body, as well as panel-footer
		3) put each field into class "form-group" which makes it that nice box with rounded corners. and add class "form-control" to add nice spacing to that new box.
	b) do the same for @app/views/devise/registrations/edit.html.erb
	c) edit @app/views/devise/sessions/new.html.erb in same way
	d) edit @app/views/devise/passwords/new.html.erb in same way
	e) edit @app/views/devise/passwords/edit.html.erb in same way
	f) rake assets:precompile RAILS_ENV=production, git push heroku master, heroku run rake db:migrate
23. Build the Logic around Users and Pins:
	Looking at Facebook, you find a lot of "resources": Images in general are a resource. They can be created, shown, edited, and deleted. Same is true in general for messages, users, your feed, videos, and so on. Looking at Twitter, tweets and users would also be resources each.
	For Pinterest and our web page, we have users and pins. Later, we will also have comments as a resource. Basically, whatever "thing/feature" you have in mind that should be possible to be created, read, updated, and destroyed you talk about a resource.

	In tech talk, that is also called CRUD. 'C'reate, 'R'ead, 'U'pdate, and 'D'estroy.

	To generate a resource, Rails has a pretty cool concept called "scaffolding" which helps us to generate resource with a single command.
	To creat a resource, we need a model, views and a controller including the CRUD methods like create a pin, read/show a pin, update a pin and delete a pin.
	"A scaffold in Rails is a full set of model, database migration for that model, controller to manipulate it, views to view and manipulate the data, and a test suite for each of the above."

	a) Resources in DB: USERS, PINS, and later: COMMENTS <-- CRUD on them. 
	--> rails g -h (see all commands possible with generatie-action)
	=> rails g scaffold Pin description:string
	--> error told me to do: rake db:migrate RAILS_ENV=development
	--> a look at http://pinmazing-mcn.dev/pins (local pins-site) shows different layout b/c of the stylesheets that were auto-added by the scaffold, c.f. scaffolds.css.scss
	--> too many files were auto-generated during the scaffold
	--> need to remove some
	--> but first go again to http://pinmazing-mcn.dev/pins and create some pins and plaz around with it 
	=> look at how URL changes -> do you get the pattern yet?. do rake routes to see.
	e.g.: "CL:To give an example, localhost:3000/pins/1/edit will call the edit action on the controller which renders the edit.html.erb in the views/pins. Based on your input there, the controller interprets your data and passes your input via the model to the database."
	b) "CL: Build out the logic for the Pins controller

	Scaffolding is very helpful when you are starting with Rails. Later you will build your resources yourself. Why?

	Scaffolds create a lot of code in the controller that we do not need and which looks pretty crazy right now. Let's delete code that we will not need to focus on understanding the important parts of the Pins-controller:

	- delete JSON files 
	- What is that and why dont we need it?
	- simplify the controller and also delete the JSON code"
	=> deleted app/views/pins/index.json.jbuilder
	=> deleted app/views/pins/show.json.jbuilder, we do not need those files. They are only confusing at the moment.
	c) added some if-else statements in the pins_controller.rb
	d) Responders
		--> explanation of Responders in rails: http://asciicasts.com/episodes/224-controllers-in-rails-3
		--> "How does the respond_with method work? For a simple GET request like index it looks for a view file to render for the appropriate MIME type, such as an .html.erb file and will render it. If respond_with fails to find a view file then it will try to call a method like to_xml or to_json to render the object that was passed in the appropriate format."
	e) Edit _form.html.erb to include bootstrap-styling
24. CONNECT USERS TO THEIR RESPECTIVE PINS (Currently: anyone can access and create pins. Let's change that to only registered people to be able to create pins.)
	a) First of all, we have to connect users and pins, because pins can be created and deleted by anyone. Right now, your app does not know a pin belongs to a user. It is rather like: "oh, there are users and also there are pins", unaware of any connection.
	We have to teach our app next that there is a connection, but wait...What type of a connection is it?

	Resources can have 6 different types of relationships, let's go through them one by one.

	belongs_to, has_one, .... show all 6 types on rails basics page

	To define associations, you have to keep always 2 steps in mind:

	1. define the type of associations in your models

	2. tell your database that there is a connection by doing a migration
	=> in MODEL user.rb and pin.rb, create the relation
	=> rails generate migration AddUserIdToPins user_id:integer:index
	=> rake db:migrate

	b) check Commands in the Rails console:
		> pin = Pin.first
		> pin # will show you the first pin, as you just put it in that variable
		> pin.user_id = 1
		> pin.save
		> user = User.first 
		> user.pins
	The cool thing is that we have the following associations now set up:
		user.pins
		pin.user
	c) Adjust the frontend views to reflect the backend associations

	So far, we only did the connection between users and pins in the console. This is not reflected in the app yet. We do this by updating our controller and views.

	Devise helps us here with a method called "current_user". "Current_user" gives us the user that initiated the controller action.
	=> in pins_controller.rb: 
		=> in def new end: instead of @pin = Pin.new, it needs to be @pin = current_user.pins.build
		=> same in def create end
		--> pin.user and user.pins works NOW!
		=> add new method def correct_user end into private-methods-section
	=> precompiled, pushed to git and heroku; had to add config.secret_key into devise.rb somewhere in the process
	=> added :image to permitted-params in pins_controller
	d) Update the pins view: app/views/pins/index.html.erb
		=> <%= pin.user.name if pin.user %>
	e) Let's make sure that only people that created a pin can change and delete a pin. And also that pins can only be created when logged in.
	=> Add devise User authentication so that you have to be logged in to create pins: app/controllers/pins_controller.rb: before_action :authenticate_user!, except: [:index, :show]
	Check to create a pin now at localhost:3000.
	f) Let's go one step further and only show the "edit" and "destroy" links when the current_user is also the creator of the pin.
	=> Check if user belongs to pin: app/views/pins/index.html.erb: added if-statement in loop-block
	=> Check if user belongs to pin: app/views/pins/show.html.erb: wrapped Edit-link into if-statement
	=> Check if user is signed in to create pin: app/views/pins/index.html.erb: wrapped link to New-Pin in footer into an if-statement
	=> What if someone types in manually a pin#edit url and wants to hack it. We can add another before_action before editing or destroying a pin to check for the correct user. We check if the pins really belongs to the current user by writing a method that calls the pin the user is looking at through the current user. If the pin is not found, itmeans that the pin does not belong to the correct_user. If that is the case, we send the user a notice and redirect.
		=> Add correct_user method: app/controllers/pins_controller.rb: 
		before_action :correct_user, only: [:edit, :update, :destroy]
		[...]
		private
		[...]
		def correct_user
 		 	@pin = current_user.pins.find_by(id: params[:id])
  			redirect_to pins_path, notice: "Not authorized to edit this pin" if @pin.nil?
		end
25. ISSUE-FIXING POSTGRES & HEROKU:
	Issues:
	- live data did not get saved for some reason (I checked on Heroku dataclips; DB kept staying empty)
	- noticed HEROKU_POSTGRESQl_xx did not have a color-name yet
		=> manually deleted that database and created a new one
		=> new one: HEROKU_POSTGRESQL_ROSE_URL
	- Multiple errors came up, e.g.: 
		-> heroku run rake db:migrate did not work anymore. Command threw different errors, including:

		 " PG::ConnectionBad: could not connect to server: Connection refused. Is the server running on host "localhost" (127.0.0.1) and accepting TCP/IP connections on port 5432?"

		 '/Applications/Postgres.app/Contents/Versions/9.4/bin'/psql -p5432
		 psql: could not connect to server: No such file or directory. Is the server running locally and accepting
	     connections on Unix domain socket "/tmp/.s.PGSQL.5432"?

		=> re-installed newer version of Postgres to fix issues with Postgres and Yosemite-OS, via Ryan Bates Tutorial:
			1. brew unlink postgresql
			2. brew install postgresql
			3. initdb /usr/local/var/postgres
			4. which psql
			5. rails new blog -d postgresql (creates new rails app with postgres-databse attached)
			gem install pg (might need to reinstall to use correct pg-version)
			6. rake db:create:all
			7. rake db:migrate
			8. rails db
			9. select * from pins;
			10. \h to see sql-query-command, or \?, or \h SELECT 

			migrating an existing database to pg:
			- update database.yml file
			- update gemfile
			- run rake db:create:all
			- migrate the data with using the gem taps => gem install taps

			gem install taps
			taps
			taps server sqlite://db/development.sqlite3 rbates secret (existing db)
			taps pull postgres://rbates@localhost/store_development http://rbates:secret@localhost:5000 (put existing data into this one now)

		=> changed all Databases in database.yml to postgresql
	- that brough additional issues 
		-> whole app did no show up on Heroku anymore (red heroku error)
		->  at some point I had different evrsions of PG running in console and on the app (9.3 and 9.4.)
	- OTHER THINGS I TRIED:
		=> reinstalled pg-gem some times:
			1. gem uninstall pg
			2. gem install pg -- --with-pg-config=/usr/local/bin/pg_config
		=> changed port to 5433 (and later back to 5432) in postgresql.config-file in /usr/local/var/postgres (did not help I think)
		=> manual stop-command stopped a lot of randomly running processes

	- COMMANDS:
		#find postgres 						cd /usr/local/var/postgres/

		#what is running on port 5432		sudo netstat -ant|grep 5432

		#PG running?/what is running?		ps auxw | grep postgres

		#config-file						egrep 'listen|port' /usr/local/var/postgres/postgresql.conf

		#remove file 	 					rm -f /tmp/.s.PGSQL.5432

		#start Postgres manually 			pg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start

		#Stop Postgres manually 			pg_ctl -D /usr/local/var/postgres stop -s -m fast

		#try get PG-server running 			postgres -D /usr/local/pgsql/data
			=> error: postgres cannot access the server configuration file "/usr/local/pgsql/data/postgresql.conf": No such file or directory

		#Check if server is running 		pg_ctl -D /usr/local/var/postgres status

		#Access Heroku-postgres-database	heroku pg:psql rose
											heroku pg:ps rose

		#Getting into my live-db from CLI 	heroku pg:psql --app pitchmatters HEROKU_POSTGRESQL_ROSE

		#DB-Query from PG-CLI				select*from Pins;

	- HELFPUL LINKS:
	http://stackoverflow.com/questions/7975556/how-to-start-postgresql-server-on-mac-os-x

	- SOLUTION:
		1. Postgres / Yosemite fix (re-installed PG)
		2. switch all DB's to Postgres
		3. on Heroku Databases, ROSE was set to Primary:NO => Changed settings to "Primary" --> everythign worked again!
		=> the two different paths mentioned in error-alerts, a) var/run/postgresql while postgresql.conf was configured to b) "/tmp" was not the issue as I thought)


26. IMAGE-UPLOAD: http://cactuslab.com/imagemagick/
	a) identify -version
	b) gem 'paperclip'
	c) bundle install
	d) https://github.com/thoughtbot/paperclip => continue from Quick Start section
		=> add these two lines to pin.rb:
  			1) has_attached_file :image, :styles => { :medium => "300x300>", :thumb => "100x100>" }, :default_url => "/images/:style/missing.png"
  			2) validates_attachment_content_type :image, :content_type => /\Aimage\/.*\Z/
  		=> rails generate paperclip pin image (similar to devise; adds image-attachment to pins-db)
  		=> rake db:migrate
  	e) Adjust views to use new DB-attribute: 
  	=> added form-group Block to pins/_form.html.erb (form_file, c.f. Quick Start instructions)
  	=> We also have to add the multipart: true to our file, because, we have a file upload field on our page.
  	f) Adjust Controller:
  	=> Next, we have to make our app work with images and that it is ok to work with images. The technical term is called strong parameters and we have to permit images to make sure that the user can upload pictures. Otherwise, only the description would be saved: in pins_controller.rb: add ":image" to private mehtod pin_params
  	g) Try to upload a picture next and click "create". Why don't we see the picture? Because we have to show it in our show view for the pin, in views/pins/show.html.erb:
  	=> bootstrap-panels
  	=> We removed the notice at the top, because we already have flash messages. We then added an image tag with the picture.
  	h) Next, let's show all created pins visually on the pins overview listings page, and make the pictures linking to the show pages for each pin (on ....com/pins):
  	=> in pins/index.html.erb:
  	Added table headers "Image" and "Name"; in tbody added link_to image-url; --> imags still next to each other
  	h) Whenever you create a pin, the picture will be saved in public/system/ (check that if you like). The issue is that when you upload your work to github, also the pictures are getting uploaded. This does not make sense, as they are huge and are not relevant for your code:
  	=> add them to the .gitignore-file
  	=> also added log, tmp, and DS_Store. Those are also irrelevant for Github.
27. AMASON S3 Image-Upload:
	- Heroku picture upload up to 50MB (50-100 images)
	- Fun fact: If you know dropbox, they store all your data in Amazon S3, too and do not do the storing themselves. For you it looks like your files are all in your dropbox. In fact they are stored at Amazon S3 as dropbox saves them there without showing you.
	a) add aws-gem: https://github.com/aws/aws-sdk-ruby, https://devcenter.heroku.com/articles/paperclip-s3
	b) Specify AWS configuration variables in config/environments/production.rb: 
	c) Creaet AWS account: You might have guessed that S3_BUCKET_NAME and the other two will be sort of your way of authentification with Amazon S3. To get them, we have to sign up with AWS. Go to http://aws.amazon.com/.
	d) In AWS, create an S3 bucket and grant permission to everyone in 'Actions->Permissions'.
	e) Setting the keys for heroku in your terminal: Important is that you will only get them once and I also do not recommend to paste them anywhere else then what we are going to do next. To be more explicit: The worst thing you can do is, put them directly in your config/environments/production.rb. With the next git push, those keys will be available to everyone and there are cases where accounts got hacked and people had to pay thousands of dollars.
	Again, only paste the keys into the CLI - nowhere else:
		heroku config
		heroku config:set S3_BUCKET=pitchmatters
		heroku config:set AWS_ACCESS_KEY_ID=***GET FROM AMAZON AWS***
		heroku config:set AWS_SECRET_ACCESS_KEY=***GET FROM AMAZON AWS***
		heroku config
	Heroku config shows you your configurations variables. After adding the AWS variables, they will also show up, when you type in heroku config after adding them. Why did we do this? Well, your config/environments/production.rb can access them on heroku then.

	Finally, push your changes to git and heroku.

	Add a new image and check the image url! Cool, right. You stored images in Amazon S3... :-)
28. NEXT-LEVEL: STYLING WITH JQUERY:
	

- put env's back into production.rb
- take @pins out again of controller
- fix "missing bucket option" 


_XX. COMMIT-ORDER:
"Also, remember to commit your changes before trying to push to Heroku, because you are pushing the master branch, not the local code."
	rake assets:precompile RAILS_ENV=production
	git add --all
	git commit -m ""
	git push origin master
	git push heroku master
	heroku run rake db:migrate


_YY EXERCISES/EXTRAS:
- try to download a live-databas (pull?)
- TOOLTIPS???
- Make error-pages pretty
- edit bootstrap alert messages such as "Pin was created successfully"
- rename "pitchmatters" everywhere!!

========================
in rails c:
#remove db-entries:		Pin.first.destroy


















	

















